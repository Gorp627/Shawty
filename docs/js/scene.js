// docs/js/playerController.js
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js'; // Using jsdelivr URL
import { PointerLockControls } from './PointerLockControls.js';
import { sendPlayerUpdate, sendShootEvent, sendPlayerDiedEvent } from './network.js';
import { getEnvironmentMeshes, getCamera, PLAYER_HEIGHT, FALL_DEATH_Y } from './scene.js';
import { showDeathScreen, hideDeathScreen, updateHealth } from './ui.js';

let controls = null;
let camera = null;
let isPointerLocked = false;
let localPlayerId = null;
let localPlayerState = {
    position: new THREE.Vector3(0, PLAYER_HEIGHT + 80, 0),
    velocity: new THREE.Vector3(),
    rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
    onGround: false, isDead: false, health: 100, lastUpdateTime: 0,
    canDash: true, canShoot: true, isPropulsionShot: false, canJump: true
};
const moveState = { forward: 0, right: 0, jumping: false, dashing: false };
let collisionRaycaster = null;
let groundCheckRaycaster = null;

const MOVE_SPEED = 5.0; const DASH_SPEED_MULTIPLIER = 3.0; const DASH_DURATION = 0.15;
const DASH_COOLDOWN = 1.0; const JUMP_VELOCITY = 6.0; const PROPULSION_FORCE = 25.0;
const SHOOT_COOLDOWN = 0.2; const GRAVITY = -15.0; const NETWORK_UPDATE_INTERVAL = 100;

export function initPlayerController(cam, canvas, playerId) {
    if (!cam || !canvas || !playerId) { console.error("initPlayerController called with invalid arguments"); return; }
    console.log("Initializing PlayerController for ID:", playerId);
    camera = cam; localPlayerId = playerId;
    collisionRaycaster = new THREE.Raycaster();
    groundCheckRaycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, PLAYER_HEIGHT * 0.6 + 0.1 );
    try { controls = new PointerLockControls(camera, canvas); console.log("PointerLockControls instantiated."); }
    catch (e) { console.error("!!! Failed to instantiate PointerLockControls:", e); alert("Error initializing controls. Check console."); return; }
    canvas.addEventListener('click', () => { if (!localPlayerState.isDead && controls && !isPointerLocked) { console.log("Canvas clicked, requesting pointer lock."); controls.lock(); } });
    controls.addEventListener('lock', () => { isPointerLocked = true; console.log("Pointer Locked"); });
    controls.addEventListener('unlock', () => { isPointerLocked = false; console.log("Pointer Unlocked"); });
    document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); canvas.addEventListener('mousedown', onMouseDown);
    updateHealth(localPlayerState.health); console.log("PlayerController initialization complete.");
}
function onKeyDown(event) { if (!isPointerLocked || localPlayerState.isDead) return; switch (event.code) { case 'KeyW': case 'ArrowUp': moveState.forward = 1; break; case 'KeyS': case 'ArrowDown': moveState.forward = -1; break; case 'KeyA': case 'ArrowLeft': moveState.right = -1; break; case 'KeyD': case 'ArrowRight': moveState.right = 1; break; case 'Space': if (localPlayerState.canJump && localPlayerState.onGround && !moveState.jumping) { localPlayerState.velocity.y = JUMP_VELOCITY; localPlayerState.onGround = false; moveState.jumping = true; localPlayerState.canJump = false; console.log("Jump initiated."); } break; case 'ShiftLeft': if (localPlayerState.canDash && !moveState.dashing) { moveState.dashing = true; localPlayerState.canDash = false; setTimeout(() => { moveState.dashing = false; console.log("Dash finished."); }, DASH_DURATION * 1000); setTimeout(() => { localPlayerState.canDash = true; console.log("Dash cooldown finished."); }, DASH_COOLDOWN * 1000); console.log("Dash initiated."); } break; case 'KeyE': localPlayerState.isPropulsionShot = true; break; } }
function onKeyUp(event) { switch (event.code) { case 'KeyW': case 'ArrowUp': if (moveState.forward > 0) moveState.forward = 0; break; case 'KeyS': case 'ArrowDown': if (moveState.forward < 0) moveState.forward = 0; break; case 'KeyA': case 'ArrowLeft': if (moveState.right < 0) moveState.right = 0; break; case 'KeyD': case 'ArrowRight': if (moveState.right > 0) moveState.right = 0; break; case 'Space': moveState.jumping = false; localPlayerState.canJump = true; break; case 'KeyE': localPlayerState.isPropulsionShot = false; break; } }
function onMouseDown(event) { if (!isPointerLocked || localPlayerState.isDead || !localPlayerState.canShoot) return; if (event.button === 0) { localPlayerState.canShoot = false; setTimeout(() => localPlayerState.canShoot = true, SHOOT_COOLDOWN * 1000); if (!camera) { console.error("Camera not available for shooting direction."); return; } const direction = new THREE.Vector3(); camera.getWorldDirection(direction); sendShootEvent({ propulsion: localPlayerState.isPropulsionShot, direction: {x: direction.x, y: direction.y, z: direction.z} }); if (localPlayerState.isPropulsionShot) { applyPropulsion(direction); } } }
function applyPropulsion(shootDirection) { const propulsionVector = shootDirection.clone().negate().multiplyScalar(PROPULSION_FORCE); propulsionVector.y += PROPULSION_FORCE * 0.2; localPlayerState.velocity.add(propulsionVector); localPlayerState.onGround = false; console.log("Applied client-side propulsion force."); }
export function handleServerPropulsion(data) { console.log("Received server confirmation for propulsion."); }
export function applyKnockback(knockbackVector) { if (localPlayerState.isDead) return; if (!knockbackVector) { console.warn("applyKnockback called with invalid vector"); return; } const force = new THREE.Vector3(knockbackVector.x, knockbackVector.y, knockbackVector.z); localPlayerState.velocity.add(force); localPlayerState.onGround = false; console.log("Applied server knockback force:", force); }
export function updatePlayer(deltaTime) { if (!controls || !camera || !collisionRaycaster || !groundCheckRaycaster || !localPlayerId) { return; } const delta = Math.min(deltaTime, 0.05); const time = performance.now(); if (localPlayerState.isDead) { localPlayerState.velocity.x = 0; localPlayerState.velocity.z = 0; localPlayerState.velocity.y += GRAVITY * delta * 0.5; localPlayerState.position.addScaledVector(localPlayerState.velocity, delta); camera.position.copy(localPlayerState.position); camera.position.y += PLAYER_HEIGHT * 0.8; return; } if (!localPlayerState.onGround) { localPlayerState.velocity.y += GRAVITY * delta; } else { localPlayerState.velocity.y = Math.max(0, localPlayerState.velocity.y); } const speed = moveState.dashing ? MOVE_SPEED * DASH_SPEED_MULTIPLIER : MOVE_SPEED; const moveDirection = new THREE.Vector3(moveState.right, 0, moveState.forward); moveDirection.normalize(); if (controls && controls.isLocked) { const cameraQuaternion = camera.quaternion; const yRotation = new THREE.Euler().setFromQuaternion(cameraQuaternion, 'YXZ').y; const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yRotation); moveDirection.applyQuaternion(rotationQuaternion); } localPlayerState.velocity.x = moveDirection.x * speed; localPlayerState.velocity.z = moveDirection.z * speed; const environment = getEnvironmentMeshes(); if (environment.length > 0) { handleCollisions(delta, environment); } else { localPlayerState.position.addScaledVector(localPlayerState.velocity, delta); localPlayerState.onGround = false; } if (localPlayerState.position.y < FALL_DEATH_Y) { console.log("Player fell below death threshold!"); handleDeath(); return; } camera.position.copy(localPlayerState.position); camera.position.y += PLAYER_HEIGHT * 0.8; if (time - localPlayerState.lastUpdateTime > NETWORK_UPDATE_INTERVAL) { if (controls) { localPlayerState.rotation.setFromQuaternion(camera.quaternion, 'YXZ'); } else { console.warn("Controls missing during network update, using last known rotation."); } sendPlayerUpdate({ position: { x: localPlayerState.position.x, y: localPlayerState.position.y, z: localPlayerState.position.z }, rotation: { x: localPlayerState.rotation.x, y: localPlayerState.rotation.y, z: localPlayerState.rotation.z }, }); localPlayerState.lastUpdateTime = time; } }
function handleCollisions(deltaTime, environment) { const currentPos = localPlayerState.position; const velocity = localPlayerState.velocity; const capsuleRadius = 0.4; const capsuleHeight = PLAYER_HEIGHT; const stepDelta = deltaTime; groundCheckRaycaster.ray.origin.copy(currentPos).y += capsuleRadius; const groundIntersects = groundCheckRaycaster.intersectObjects(environment, true); let foundGround = false; if (groundIntersects.length > 0) { const groundDist = groundIntersects[0].distance; if (velocity.y <= 0) { currentPos.y -= (groundDist - capsuleRadius); velocity.y = 0; foundGround = true; } } localPlayerState.onGround = foundGround; if (foundGround && !moveState.jumping) { localPlayerState.canJump = true; } const tempPosition = currentPos.clone(); tempPosition.x += velocity.x * stepDelta; if (checkWallCollision(tempPosition, environment, capsuleRadius, capsuleHeight)) { tempPosition.x = currentPos.x; velocity.x = 0; } tempPosition.z += velocity.z * stepDelta; if (checkWallCollision(tempPosition, environment, capsuleRadius, capsuleHeight)) { tempPosition.z = currentPos.z; velocity.z = 0; } tempPosition.y += velocity.y * stepDelta; if (checkWallCollision(tempPosition, environment, capsuleRadius, capsuleHeight)) { if (velocity.y > 0) { tempPosition.y = currentPos.y; velocity.y = 0; } else { if (!localPlayerState.onGround) { tempPosition.y = currentPos.y; velocity.y = 0; localPlayerState.onGround = true; if (!moveState.jumping) localPlayerState.canJump = true; } } } currentPos.copy(tempPosition); if (localPlayerState.onGround && moveState.forward === 0 && moveState.right === 0) { const dampingFactor = Math.pow(0.1, deltaTime); velocity.x *= dampingFactor; velocity.z *= dampingFactor; if (Math.abs(velocity.x) < 0.01) velocity.x = 0; if (Math.abs(velocity.z) < 0.01) velocity.z = 0; } }
function checkWallCollision(testPosition, environment, radius, height) { if (!collisionRaycaster) return false; const checkRadius = radius * 0.9; const halfHeight = height * 0.45; const checkPoints = [ testPosition.clone().add(new THREE.Vector3(0, halfHeight, 0)), testPosition.clone(), testPosition.clone().sub(new THREE.Vector3(0, halfHeight, 0)) ]; const directions = [ new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1) ]; for (const point of checkPoints) { for (const dir of directions) { collisionRaycaster.set(point, dir); collisionRaycaster.far = checkRadius; const intersects = collisionRaycaster.intersectObjects(environment, true); if (intersects.length > 0) { return true; } } } return false; }
function handleDeath() { if (localPlayerState.isDead) return; console.log("Local player death sequence started."); localPlayerState.isDead = true; localPlayerState.health = 0; localPlayerState.velocity.set(0, 0, 0); updateHealth(localPlayerState.health); showDeathScreen(); if (isPointerLocked && controls) { console.log("Unlocking pointer due to death."); controls.unlock(); } console.log("Sending playerDied event to server."); sendPlayerDiedEvent({ position: {x: localPlayerState.position.x, y: localPlayerState.position.y, z: localPlayerState.position.z} }); }
export function handleRespawn(data) { if (!data || !data.position) { console.error("handleRespawn called with invalid data:", data); return; } console.log("Local player respawning at:", data.position); localPlayerState.isDead = false; localPlayerState.health = 100; localPlayerState.position.set(data.position.x, data.position.y, data.position.z); localPlayerState.velocity.set(0, 0, 0); localPlayerState.onGround = false; updateHealth(localPlayerState.health); hideDeathScreen(); }
export function takeDamage(amount) { if (localPlayerState.isDead) return; const damageAmount = Math.max(0, amount); localPlayerState.health -= damageAmount; localPlayerState.health = Math.max(0, localPlayerState.health); updateHealth(localPlayerState.health); console.log(`Local player took ${damageAmount} damage, health: ${localPlayerState.health}`); if (localPlayerState.health <= 0) { handleDeath(); } }
export function getPlayerState() { return { ...localPlayerState, position: localPlayerState.position.clone(), velocity: localPlayerState.velocity.clone(), rotation: localPlayerState.rotation.clone(), }; } export function getControls() { return controls; } export function isLocked() { return isPointerLocked; }
