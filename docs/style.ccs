// server/server.js
const express = require('express');
const http = require('http');
const { Server } = require("socket.io");
const path = require('path');

const app = express();
const server = http.createServer(app);

// --- Configuration ---
const io = new Server(server, {
    cors: {
        origin: ["https://gorp627.github.io", "http://localhost:8080"], // USER'S GitHub Pages URL + localhost
        // origin: "*", // Less secure, use for debugging origin issues
        methods: ["GET", "POST"]
    }
});

const PORT = process.env.PORT || 3000;
const RESPAWN_DELAY = 4000; // milliseconds

// --- Game State ---
let players = {}; // { socket.id: { id, x, y, z, rotationY, health, name, phrase } }

// Function to broadcast player count
function broadcastPlayerCount() {
    const count = Object.keys(players).length;
    io.emit('playerCountUpdate', count); // Send to all connections
    console.log("Player count updated:", count);
}

// --- Socket.IO Connection Handling ---
io.on('connection', (socket) => {
    console.log(`User tentative connection: ${socket.id}`);

    // Send initial player count
    socket.emit('playerCountUpdate', Object.keys(players).length);

    // Listen for player setting their details
    socket.on('setPlayerDetails', (details) => {
        // Validate and sanitize input
        const name = details.name ? String(details.name).substring(0, 16).trim() : 'Anonymous';
        const phrase = details.phrase ? String(details.phrase).substring(0, 20).trim() : '...';
        const finalName = name === '' ? 'Anonymous' : name;
        const finalPhrase = phrase === '' ? '...' : phrase;

        if (players[socket.id]) {
            console.log(`Player ${socket.id} (${players[socket.id].name}) tried to set details again.`);
            players[socket.id].name = finalName;
            players[socket.id].phrase = finalPhrase;
            return; // Don't re-initialize
        }

        console.log(`Player ${socket.id} fully joined as "${finalName}" with phrase "${finalPhrase}"`);

        // Create player object in state
        players[socket.id] = {
            id: socket.id,
            x: Math.random() * 15 - 7.5, y: 0, z: Math.random() * 15 - 7.5, rotationY: 0,
            health: 100, name: finalName, phrase: finalPhrase
        };

        // Initialize the new player
        socket.emit('initialize', { id: socket.id, players: players });
        // Notify other players
        socket.broadcast.emit('playerJoined', players[socket.id]);
        // Broadcast updated player count
        broadcastPlayerCount();
    });

    // --- Standard Event Handlers ---
    socket.on('playerUpdate', (playerData) => {
        const player = players[socket.id];
        if (player) {
            player.x = playerData.x; player.y = playerData.y; player.z = playerData.z;
            player.rotationY = playerData.rotationY;
            socket.broadcast.emit('playerMoved', player);
        }
    });
    socket.on('shoot', (bulletData) => {
        if (!players[socket.id]) return;
        io.emit('shotFired', {
            shooterId: socket.id, position: bulletData.position,
            direction: bulletData.direction, bulletId: socket.id + "_" + Date.now()
        });
    });
    socket.on('hit', (data) => {
        const { targetId, damage } = data; const shooterId = socket.id;
        const targetPlayer = players[targetId]; const shooterPlayer = players[shooterId];
        if (targetPlayer && targetPlayer.health > 0 && shooterPlayer) {
            targetPlayer.health -= damage;
            console.log(`${targetPlayer.name} hit by ${shooterPlayer.name}. HP: ${targetPlayer.health}`);
            if (targetPlayer.health <= 0) {
                targetPlayer.health = 0; console.log(`${targetPlayer.name} defeated by ${shooterPlayer.name}`);
                io.emit('playerDied', { targetId: targetId, killerId: shooterId, killerName: shooterPlayer.name, killerPhrase: shooterPlayer.phrase });
                scheduleRespawn(targetId);
            } else { io.emit('healthUpdate', { id: targetId, health: targetPlayer.health }); }
        }
    });
    socket.on('fellIntoVoid', () => {
        const player = players[socket.id];
        if (player && player.health > 0) {
            console.log(`${player.name} fell into void.`); player.health = 0;
            io.emit('playerDied', { targetId: socket.id, killerId: null, killerName: null, killerPhrase: null });
            scheduleRespawn(socket.id);
        }
    });
    socket.on('disconnect', () => {
        const player = players[socket.id];
        if (player) { console.log(`User ${player.name} (${socket.id}) disconnected.`); delete players[socket.id]; io.emit('playerLeft', socket.id); broadcastPlayerCount(); }
        else { console.log(`User ${socket.id} (unjoined) disconnected.`); }
    });
});

// --- Helper Function for Respawns ---
function scheduleRespawn(playerId) { setTimeout(() => { const player = players[playerId]; if (player) { player.health = 100; player.x = Math.random() * 15 - 7.5; player.y = 0; player.z = Math.random() * 15 - 7.5; player.rotationY = 0; console.log(`${player.name} respawned.`); io.emit('playerRespawned', player); } }, RESPAWN_DELAY); }
// --- Basic HTTP Server ---
app.get('/', (req, res) => { const p = path.join(__dirname, 'index.html'); res.sendFile(p, (err) => { if (err) res.status(200).send('Shawty Server Running.'); }); });
// --- Start Server ---
server.listen(PORT, () => { console.log(`Shawty Server listening on *:${PORT}`); if (Array.isArray(io.opts.cors.origin)) console.log(`Allowed origins: ${io.opts.cors.origin.join(', ')}`); else console.log(`Allowed origins: ${io.opts.cors.origin}`); });
